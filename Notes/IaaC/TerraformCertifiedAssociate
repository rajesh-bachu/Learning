Terraform Certified Associate

Question types:
    - True/False
    - Multiple Choice
    - Multiple Choice - Multiple Answer
    - Text Match (Fill in the blanks)

Advantages of Certification:
    - Verify your skills as IaC practitioner
    - Expand skills and knowledge about Tf & best practices
    - Get more insight into the Enterprise features of Terraform
    - Solidify Tf fundementals and kickstart your journey to more advanced deployments.

IaC and its benefits
    - No more clicks
        - Write down what you want to deploy as human readable.
    - Enables DevOps
        - Codification of deployment means it can be tracked in version control enabling better visibility and collaboration across teams.
    - Declare your infrastructure
        - Infrastructure is, for the majority of cases, written declaratively via code but can be procedural(imperative) too!
    - Speed, Cost, and Reduced Risk
        - Less human intervention during deployment means fewer chances of security flaws, superfluous resources, and more time is saved!
     
Hashicorp Configuration Languague (HCL) > Coding language for Terraform.

Cloud Agnostivc IaC with Terraform:
    - Automate Software Defined Network
    - Interacts and takes care of communication with control layer APIs with ease.
    - Supports a vast array of private and public cloud vendors.
    - Racks state of each resource deployed!

What is the Terraform Workflow?
    - Write
        This would generally start off with creating a GitHub repo as a common best practice.
    - Plan
        You'll continually add and review changes to code in your project.
    - Apply
        After one last review/plan, you'll be ready to provision real infrastructure.

Terraform Init (Initializing the Working Directory)
    - Initializes the working directory that contains your Terraform Code.
        Downloads ancillary components (modules and plugins)
        Sets up backend (for storing Terraform state file, a mechanism by which Terraform tracks resources.)
    
Terraform Key Concepts: Plan, Apply, and Destroy
    - Plan
        - Reads the code and then creates and shows a "plan" of execution/deployment
            Note: This command does not deploy anything. Consider this a read-only command.
        - Allows the user to review the action plan before executing anything.
        - At this stage, authentication credentials are used to connect to your infrastructure, if required.
    - Apply
        - Deploys the instructions and statements in the code
        - Updates the deployment state tracking mechanism file, a.k.a. "State file"
    - Destroy
        - Looks at the recorded, stored state file created during deployment and destroys all resources created by your code
        - Should be used with caution, as it is non-reversible command. Take backups, and be sure that you want to delete your infrastructure.

Resource addressing in Terraform: Understanding Terraform Code
    - Terraform Code snippet (Configuring the provider)
    - AWS provider
        provider "aws"{
            region = "us-east-1"
        }
    - GCP provider
        provider "google"{
            credentials = file("credentials.json")
            project = "my-gcp-project"
            region = "us-west-1"
        }

    - Resource
        resource "aws_instance" "web" {
            ami = "ami-123"
            instance_type = "t2.micro"

        }   

        resource = reserved keyword
        aws_instance = Resource provided by Terraform provider
        web = User-provided arbitrary resource name
        ami, instance_type = resource config arguments

        Resource Address = aws_instance.web 

        data "aws_instance" "my-vm"{
            instance_id = "i-1234"
        }
        Resource Address = data.aws_instance.my-vm
    
    - Terraform executes the code in files with the .tf extension.
    - Initially, Terraform looks for providers in the Terraform providers registry

Providers:
    - Providers are terraform's way of abstracting integrations with API control layer of the infrastructure vendors.
    - Terraform, by default, looks for Providers in the Terraform providers registry.
    - Providers are plugins. They are released on a separate rhythm from Terraform itself, and each provider has its own series of version numbers.    
    - You can write your own custom providers as well
    - Terraform finds and installs providers when initializing working directory (via terraform init).
    - As a best practice Providers should be pegged down to a specific version, so that any changes across provider version doesn't break your Terraform code.

Terraform State:
    - Resource Tracking!
        - A way for Terraform to keep tabs on what has been deployed.
        - Critical to Terraforms functionality
        - Stored in flat files, by default named "terraform.tfstate"
        - Helps Terraform calculate deployment delta and create new deployment plans.
        - Never lose your Terraform State file!

Terraform Variables and Outputs:
    variable "my-var"{
        description = "My Test Variable"
        type = string
        default = "Hello"
    } 
    variable = reserved keyword
    User provided variable name = my-var
    variable config arguments such as type of variable and default value

    variable can also be declared as 
        variable "my-var" {}
        but in this case, you have to pass variable on runtime or as os environmental variable
    
    Referencing a variable: var.my-var
    - Best practice is to have variables in a different file: terraform.tfvars

    - Variable validation:
        variable "my-var"{
            description = "My Test Variable"
            default = "Hello"
            validation{
                condition = length(var.my-var) > 4
                  error_message = "The string must be more than 4 characters" #experimental feature in 0.12, available open from 0.13
            }
        }

        sensitive = True

        Base types:
            - string
            - number
            - bool
        Complex Types:
            - list, set, map, object, tuple
        OS environmental variables have precedence over Terraform Environmental variables

        Terraform Output - Output Values:
            output "instance_ip"{
                description = "VM's Private IP"
                value = aws_instance.my-vm.private.ip
            }
            - Output variable values are show on the shell after running terraform apply.
            - Output values are like return values that you want to track after a successful Terraform deployment.

Terraform Provisioners: When you use them?
    - Terraforms way of bootstrapping custom scripts, commands or actions
    - Can be run either locally (on the same system where Terraform commands are being issued from), or remotely on resources spun up through the Terraform deployment.
    - Within Terraform code, each individual resource can have its own "provisioner" defining the connection method (if required such as SSH or WinRM) and the actions/commands or script to execute.
    - There are 2 types of provisioners: "Creation-time" and "Destroy-time" provisioners which you can set to run when a resource is being created or destroyed.

    Best Practices and Cautions When Using Provisioners:
        - DISCLAIMER: Hashicorp recommends using Provisioners as a last resort and to try using inherent mechanisms within your infrastructure deployment to carry out custom tasks where possible.
            eg: Hashicorp recommends using EC2 user data rather than Terraform Provisioners.
        - Terraform cannot track changes to provisioners as they can take any independent action, hence they are not tracked by Terraform state files.
        - Provisioners are recommended for use when you want to invode actions not covered by Terraforms declarative model.
        - If the command within a provisioner returns non-zero return code, it's considered failed and underlying resource is tainted.
            Syntax of provisioner:
                resource "null_resource" "dummy_resource" {
                    provisioner "local-exec"{
                        command = "echo '0' > status.txt
                    }
                    provisioner "local-exec"{
                        when = destroy
                        command = "echo '1' > status.txt"
                    }
                }

Terraform State commands:

Terraform State: (State matters a lot!)
    - Simply put, it maps real-world resources to Terraform configuration.
    - By default, state is stored locally in a file called terraform.tstate (locally or remote as S3)
    - Prior to any modification operation, Terraform refreshes the state file.
    - Resource dependency metadata is also tracked via the state file.
    - Helps boost deployment performance by caching resource attributes for subsequent use.

Terraform State Command:
    - Terraform State command is a utility for manipulating and reading the Terraform state file
    - Scenario
        - Advanced state management
        - Manually remove a resource from Terraform State file so that it's not managed by Terraform
        - Listing out tracked resources and their details (via state and list subcommands)

        Common Terraform State commands
        - terraform state list > List out all resources tracked by the terraform state file
        - terraform state rm > Delete a resource from the Terraform state file
        - terraform state show > Show details of a resource tracked in the Terraform state file.
    
    - Local and Remote State Storage
        - Local State Storage
            - Saves Terraform state locally on your system.
            - Terraforms default behaviour
        - Remote State Storage
            - Saves state to a remote data source. Optional.
              Examples of storage: AWS S3, Google Storage
            - Allows sharing state file between distributed teams.
            - Remote state accessible to multiple teams for collaboration

        - State locking
            - Allows locking state so parallel executions don't coincide
            
        - State file: Enables sharing "output" values with other Terraform configuraiton or code.















